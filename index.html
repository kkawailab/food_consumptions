<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>1世帯あたり年間食料品購入量（2021〜23年平均）</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .info {
      padding: 8px 12px;
      background: white;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 4px;
      line-height: 1.35;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans CJK JP", "Noto Sans JP", Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }
    .legend { line-height: 18px; color: #555; }
    .legend i {
      width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.8;
    }
    .category-control {
      padding: 8px 12px;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 4px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans CJK JP", "Noto Sans JP", Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }
    .category-control label {
      font-weight: 600;
      margin-right: 6px;
    }
    .category-control select {
      font: inherit;
      padding: 2px 6px;
    }
    .credit { position: absolute; bottom: 6px; right: 8px; background: rgba(255,255,255,.85); padding: 4px 8px; border-radius: 4px; font-size: 12px;}
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="consumption.js"></script>
<script>
  const categoryMeta = {
    rice: { label: '米', unit: 'kg', digits: 2 },
    bread: { label: 'パン', unit: 'kg', digits: 2 },
    fish: { label: '生鮮魚介', unit: 'kg', digits: 2 },
    beef: { label: '牛肉', unit: 'kg', digits: 2 },
    pork: { label: '豚肉', unit: 'kg', digits: 2 },
    butter: { label: 'バター', unit: 'g', digits: 0 },
    vegetables: { label: '生鮮野菜', unit: 'kg', digits: 2 },
    fruit: { label: '生鮮果物', unit: 'kg', digits: 2 }
  };

  const palette = ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#084594'];
  const categoryKeys = Object.keys(categoryMeta);
  const numberFormatters = Object.fromEntries(categoryKeys.map(key => {
    const digits = categoryMeta[key].digits ?? 2;
    return [key, new Intl.NumberFormat('ja-JP', {
      minimumFractionDigits: digits,
      maximumFractionDigits: digits
    })];
  }));

  const categoryAverages = Object.fromEntries(categoryKeys.map(key => {
    const values = Object.values(consumptionData)
      .map(v => v[key])
      .filter(v => typeof v === 'number');
    const avg = values.reduce((sum, v) => sum + v, 0) / (values.length || 1);
    return [key, avg];
  }));

  let currentCategory = 'rice';
  let geojson = null;
  let scale = buildScale(currentCategory);

  const map = L.map('map', { zoomControl: true }).setView([36.2, 137.9], 5.2);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 10,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const info = L.control();
  info.onAdd = function(map) {
    this._div = L.DomUtil.create('div', 'info');
    this.update();
    return this._div;
  };
  info.update = function(props) {
    const meta = categoryMeta[currentCategory];
    const average = categoryAverages[currentCategory];
    const formatter = numberFormatters[currentCategory];
    const header = '<b>1世帯あたり年間食料品購入量（2021〜23年平均）</b><br/>' +
      meta.label + '（' + meta.unit + '）';
    const body = props && typeof props.value === 'number'
      ? props.name_ja + '：<b>' + formatter.format(props.value) + ' ' + meta.unit + '</b>'
      : '都道府県をホバーしてください。';
    const footer = '全国平均：<b>' + formatter.format(average) + ' ' + meta.unit + '</b>';
    this._div.innerHTML = header + '<br />' + body + '<hr style="margin:.5em 0"/>' + footer;
  };
  info.addTo(map);

  const categoryControl = L.control({ position: 'topright' });
  categoryControl.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'category-control');
    const label = L.DomUtil.create('label', '', div);
    label.setAttribute('for', 'categorySelect');
    label.textContent = '品目';
    const select = L.DomUtil.create('select', '', div);
    select.id = 'categorySelect';
    categoryKeys.forEach(key => {
      const option = L.DomUtil.create('option', '', select);
      option.value = key;
      option.textContent = categoryMeta[key].label + '（' + categoryMeta[key].unit + '）';
    });
    select.value = currentCategory;
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);
    select.addEventListener('change', (e) => {
      currentCategory = e.target.value;
      scale = buildScale(currentCategory);
      updateVisualization();
    });
    return div;
  };
  categoryControl.addTo(map);

  const legend = L.control({ position: 'bottomleft' });
  legend.onAdd = function(map) {
    this._div = L.DomUtil.create('div', 'info legend');
    updateLegend();
    return this._div;
  };
  legend.addTo(map);

  const credit = L.control({ position: 'bottomright' });
  credit.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'credit');
    div.innerHTML = '出典：総務省「家計調査」2021〜23年平均、境界データ：dataofjapan/land';
    return div;
  };
  credit.addTo(map);

  const GEOJSON_URL = 'https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson';

  fetch(GEOJSON_URL)
    .then(r => r.json())
    .then(data => {
      geojson = L.geoJson(data, { style, onEachFeature }).addTo(map);
      map.fitBounds(geojson.getBounds(), { padding: [10, 10] });
      updateVisualization();
    })
    .catch(err => {
      console.error(err);
      alert('境界データの取得に失敗しました。ネットワーク接続をご確認ください。');
    });

  function style(feature) {
    const pref = getPrefName(feature);
    return {
      fillColor: getColor(getValue(pref)),
      weight: 1,
      opacity: 1,
      color: '#777',
      fillOpacity: 0.85
    };
  }

  function onEachFeature(feature, layer) {
    const pref = getPrefName(feature);
    layer.bindPopup(formatPopupContent(pref));
    layer.on({
      mouseover: (e) => {
        e.target.setStyle({ weight: 2, color: '#333' });
        info.update({ name_ja: pref, value: getValue(pref) });
      },
      mouseout: (e) => {
        geojson.resetStyle(e.target);
        info.update();
      },
      click: () => layer.openPopup()
    });
  }

  function getPrefName(feature) {
    const props = feature.properties || {};
    return props.nam_ja || props.name_ja || props.name || '';
  }

  function getValue(pref, category = currentCategory) {
    return consumptionData[pref] ? consumptionData[pref][category] : undefined;
  }

  function buildScale(category) {
    const values = Object.values(consumptionData)
      .map(v => v[category])
      .filter(v => typeof v === 'number');
    if (!values.length) {
      return { ranges: [] };
    }
    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min;
    const step = range / palette.length;
    const ranges = palette.map((color, idx) => {
      const from = range === 0 ? min : min + step * idx;
      const to = range === 0 ? max : min + step * (idx + 1);
      return { from, to, color };
    });
    return { ranges };
  }

  function getColor(value) {
    if (typeof value !== 'number' || !scale.ranges.length) {
      return '#ccc';
    }
    for (let i = scale.ranges.length - 1; i >= 0; i--) {
      if (value >= scale.ranges[i].from) {
        return scale.ranges[i].color;
      }
    }
    return scale.ranges[0].color;
  }

  function formatPopupContent(pref) {
    const meta = categoryMeta[currentCategory];
    const value = getValue(pref);
    if (typeof value !== 'number') {
      return '<b>' + pref + '</b><br/>データなし';
    }
    const formatter = numberFormatters[currentCategory];
    return '<b>' + pref + '</b><br/>' + meta.label + '：' + formatter.format(value) + ' ' + meta.unit;
  }

  function updateLegend() {
    if (!legend._div || !scale.ranges.length) {
      if (legend._div) {
        legend._div.innerHTML = 'データなし';
      }
      return;
    }
    const meta = categoryMeta[currentCategory];
    const formatter = numberFormatters[currentCategory];
    const rows = scale.ranges.map((range, idx) => {
      const from = formatter.format(range.from);
      if (idx === scale.ranges.length - 1) {
        return '<i style="background:' + range.color + '"></i> ' + from + ' ' + meta.unit + '以上';
      }
      const to = formatter.format(range.to);
      return '<i style="background:' + range.color + '"></i> ' + from + '〜' + to + ' ' + meta.unit;
    });
    legend._div.innerHTML = rows.join('<br>');
  }

  function updateVisualization() {
    if (geojson) {
      geojson.setStyle(style);
      geojson.eachLayer(layer => {
        const pref = getPrefName(layer.feature);
        layer.bindPopup(formatPopupContent(pref));
      });
    }
    updateLegend();
    info.update();
  }
</script>
</body>
</html>
